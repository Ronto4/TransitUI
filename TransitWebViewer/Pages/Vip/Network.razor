@page "/vip/network"
@using System.Text
@using Timetable
@using TransitWebViewer.Utils
@using VipTimetable
<h3>Network</h3>

@code {

    private static readonly IHistoryEntry Entry = VipHistory.History.Last();

    private static readonly NetworkGraph NetworkGraph = new(Entry);

    // private static readonly DaysOfOperation[] DaysPartition =
    // [
    //     DaysOfOperation.SchoolMonday,
    //     DaysOfOperation.SchoolTuesday,
    //     DaysOfOperation.SchoolWednesday,
    //     DaysOfOperation.SchoolThursday,
    //     DaysOfOperation.SchoolFriday,
    //     DaysOfOperation.HolidayMonday,
    //     DaysOfOperation.HolidayTuesday,
    //     DaysOfOperation.HolidayWednesday,
    //     DaysOfOperation.HolidayThursday,
    //     DaysOfOperation.HolidayFriday,
    //     DaysOfOperation.Saturday,
    //     DaysOfOperation.Sunday
    // ];
    //
    // private readonly record struct StopStatistic
    // {
    //     public required Stop Stop { get; init; }
    //     public required int[] Departures { get; init; }
    //     public int TotalDepartures => Departures.Sum();
    //
    //     public static StopStatistic GetFromTrips(Stop stop, (Line.Route Route, int[] TripCount)[] routes)
    //     {
    //         Console.WriteLine($"Stop: {stop.DisplayName(DateOnly.FromDateTime(DateTime.Now), Cities.Potsdam)}");
    //         Console.Out.Flush();
    //         var relevantRoutes = routes.Where(route => route.Route.DoesStopAt(stop, true));
    //         return new StopStatistic
    //         {
    //             Stop = stop,
    //             Departures = DaysPartition.Select((_, daysIndex) => relevantRoutes.Aggregate(0, (previous, route) => previous + route.TripCount[daysIndex])).ToArray(),
    //         };
    //     }
    // }
    //
    // private readonly record struct ConnectionStatistic
    // {
    //     public required Stop StartStop { get; init; }
    //     public required Stop NeighbouringStop { get; init; }
    //     public required int TotalTrips { get; init; }
    // }
    //
    // private static IOrderedEnumerable<StopStatistic> GetStopStatistics(IHistoryEntry historyEntry)
    // {
    //     var lines = historyEntry.LinesById.Select(kvp => kvp.Value).ToArray();
    //     var routes = lines.SelectMany(line => line.Routes).Select(route => (route, DaysPartition.Select(days => route.TripCount(days) ?? 0).ToArray())).ToArray();
    //     var stops = lines.SelectMany(line => line.Routes).SelectMany(route => route.StopPositions).Select(position => position.Stop).Distinct();
    //     var stats = stops.Select(stop => StopStatistic.GetFromTrips(stop, routes)).OrderByDescending(stat => stat.TotalDepartures);
    //     return stats;
    // }
    //
    // private static IEnumerable<(Stop Stop, IOrderedEnumerable<ConnectionStatistic> ConnectionStats)> GetAllConnectionStatistics(IHistoryEntry historyEntry)
    // {
    //     var stopStats = GetStopStatistics(historyEntry);
    //     return stopStats.Select(stopStat => (stopStat.Stop, GetConnectionStatistics(historyEntry, stopStat.Stop)));
    // }
    //
    // private static IOrderedEnumerable<ConnectionStatistic> GetConnectionStatistics(IHistoryEntry historyEntry, Stop startStop)
    // {
    //     var lines = historyEntry.LinesById.Select(kvp => kvp.Value);
    //     var relevantRoutes = lines.SelectMany(line => line.Routes).Where(route => route.DoesStopAt(startStop, true));
    //     var neighbouringStops = relevantRoutes.Select(route => (TripCount: route.TripCount(DaysOfOperation.Daily), NeighbouringStop: route.StopPositions[route.GetIndexOfStopFirst(startStop) + 1].Stop));
    //     return neighbouringStops
    //         .GroupBy(tuple => tuple.NeighbouringStop)
    //         .Select(group => (NeighbouringStop: group.Key, TotalTrips: group.Aggregate(0, (previous, g) => previous + g.TripCount ?? 0)))
    //         .Select(tuple => new ConnectionStatistic { StartStop = startStop, NeighbouringStop = tuple.NeighbouringStop, TotalTrips = tuple.TotalTrips })
    //         .OrderByDescending(stat => stat.TotalTrips);
    // }

    private record Node
    {
        public required Stop Stop { get; init; }
        public required (int X, int Y) Position { get; init; }

        private int UsedNeighbourPositions { get; set; } = 0;
        // /// <summary>
        // /// Indicates which #child this node is from its parent.
        // /// </summary>
        // private int? IncomingPositionIndex { get; init; } = null;
        private int Depth { get; init; } = 0;
        public Node MakeNext(Stop stop)
        {
            var (position, angle) = (NextPosition(), 0);
            UsedNeighbourPositions++;
            return new Node
            {
                Stop = stop,
                Position = position,
                // IncomingPositionIndex = UsedNeighbourPositions,
                Depth = Depth + 1,
            };
        }

        private (int X, int Y) NextPosition() => Positions().Skip(UsedNeighbourPositions).First();

        private const int LevelDistance = 10;
        private const int LevelMultiplier = 10;
        private IEnumerable<(int X, int Y)> Positions()
        {
            var multiplier = Math.Max(LevelMultiplier - Depth, 1);
            yield return (Position.X, Position.Y + LevelDistance);
            for (var i = 1; i < LevelDistance; ++i)
            {
                yield return (Position.X + (LevelDistance - i) * multiplier, Position.Y + i * multiplier);
                yield return (Position.X + (-LevelDistance + i) * multiplier, Position.Y + i * multiplier);
            }

            throw new Exception($"Too many neighbours");
        }

        public int Id => GetHashCode();
    }

    private readonly record struct Connection
    {
        public required Node From { get; init; }
        public required Node To { get; init; }
        public required NetworkGraph.LineSegment Source { get; init; }
    }

    private static (IReadOnlyCollection<Node> nodes, IReadOnlyCollection<Connection> connections) GetGraph()
    {
        var lineSegments = NetworkGraph.TraverseLineWise().ToArray();
        var nodeMap = new Dictionary<Stop, Node>();
        var connections = new List<Connection>(lineSegments.Length);
        var nodes = new List<Node>();
        nodes.Add(new Node
        {
            Stop = lineSegments[0].From,
            Position = (0, 0),
        });
        nodeMap.Add(lineSegments[0].From, nodes[0]);
        foreach (var lineSegment in lineSegments)
        {
            // This must exist already.
            var fromNode = nodeMap[lineSegment.From];
            if (nodeMap.TryGetValue(lineSegment.To, out var toNode))
            {
                connections.Add(new Connection
                {
                    From = fromNode,
                    To = toNode,
                    Source = lineSegment,
                });
                continue;
            }

            var newToNode = fromNode.MakeNext(lineSegment.To);
            nodes.Add(newToNode);
            nodeMap.Add(lineSegment.To, newToNode);
            connections.Add(new Connection
            {
                From = fromNode,
                To = newToNode,
                Source = lineSegment,
            });
        }
        return (nodes, connections);
    }

    private static readonly (IReadOnlyCollection<Node> nodes, IReadOnlyCollection<Connection> connections) Graph = GetGraph();

    private static string PrintTikZ()
    {
        var sb = new StringBuilder();
        sb.AppendLine("\\begin{tikzpicture}");
        // Node styles
        sb.AppendLine("\\tikzstyle{stop} = [rectangle, minimum width=7em, minimum height=7em,text centered, draw=black]");
        // Connection styles
        // sb.AppendLine("\\tikzstyle{connection} = [draw = red,thick,{Latex[length=0.75em]}-{Latex[length=0.75em]}]");
        sb.AppendLine("\\tikzstyle{connection} = [draw = red,thick]");
        // Nodes = Stops
        foreach (var node in Graph.nodes)
        {
            sb.AppendLine($"\t\\node ({node.Id}) [stop] at ({node.Position.X}em, {node.Position.Y}em) {{{node.Stop.DisplayName(DateOnly.FromDateTime(DateTime.Now), Cities.Potsdam)}}};");
        }
        // Connections
        foreach (var connection in Graph.connections)
        {
            // sb.AppendLine($"\\draw [connection] ({connection.From.Id}) -- ({connection.To.Id});");
        }
        sb.AppendLine("\\end{tikzpicture}");
        return sb.ToString();
    }

}

@* <ol> *@
@*     @foreach (var node in Graph.nodes) *@
@*     { *@
@*         <li> *@
@*             @node *@
@*         </li> *@
@*     } *@
@* </ol> *@
@* *@
@* <ol> *@
@*     @foreach (var connection in Graph.connections) *@
@*     { *@
@*         <li> *@
@*             @connection *@
@*         </li> *@
@*     } *@
@* </ol> *@

@* @PrintTikZ() *@

@* <ol> *@
@*     @foreach (var connection in NetworkGraph.TraverseLineWise()) *@
@*     { *@
@*         <li> *@
@*             @connection.Line.Name: @connection.From.DisplayName(DateOnly.FromDateTime(DateTime.Now), Cities.Potsdam) *@
@*             &rarr; *@
@*             @connection.To.DisplayName(DateOnly.FromDateTime(DateTime.Now), Cities.Potsdam) *@
@*             (@connection.TripCount Fahrten) *@
@*         </li> *@
@*     } *@
@* </ol> *@
@* *@
@foreach (var ((stop, stopStatistic), index) in NetworkGraph.TraverseMostUsedStops().Select((value, index) => (value, index)))
{

    <h5>@(index + 1). FÃ¼r Starthaltestelle @stop.DisplayName(DateOnly.FromDateTime(DateTime.Now), Cities.Potsdam) (@stopStatistic.TotalDepartures Abfahrten):</h5>

    <table class="table table-hover table-striped">
        <thead >
        <tr >
            <th scope="col"> Position </th >
            <th scope="col"> Linie </th >
            <th scope="col"> Gesamte Fahrten </th >
        </tr >
        </thead >
        <tbody >
        @foreach (var ((line, trips), rank) in stopStatistic.DeparturesByLine.OrderByDescending(tuple => tuple.Value).Select((value, index) => (value, index)))
        {
            <tr>
                <td>@(rank + 1)</td>
                <th scope="row">@line.Name</th>
                <td>@trips</td>
            </tr>
        }
        </tbody>
    </table>

    <table class="table table-hover table-striped">
        <thead >
        <tr >
            <th scope="col"> Position </th >
            <th scope="col"> Name </th >
            <th scope="col"> Gesamte Fahrten </th >
            <th scope="col"> Fahrzeiten </th>
        </tr >
        </thead >
        <tbody >
        @foreach (var (stat, rank) in stopStatistic.Connections.OrderBy(stat => stat.TripTime.maximumTime).ThenBy(stat => stat.TripTime.minimumTime).ThenByDescending(stat => stat.TotalTrips).Select((stat, index) => (stat, index)))
        {
            <tr>
                <td>@(rank + 1)</td>
                <th scope="row">@stat.NeighbouringStop.DisplayName(DateOnly.FromDateTime(DateTime.Now), Cities.Potsdam)</th>
                <td>
                    @stat.TotalTrips
                    (@string.Join(", ", stat.TripsByLine.OrderByDescending(trips => trips.Value).Select(trips => $"{trips.Key.Name}: {trips.Value}")))
                </td>
                <td>@stat.TripTime.minimumTime bis @stat.TripTime.maximumTime</td>
            </tr>
        }
        </tbody>
    </table>

}

@* <table class="table table-hover table-striped"> *@
@*     <thead> *@
@*     <tr> *@
@*         <th scope="col">Position</th> *@
@*         <th scope="col">Name</th> *@
@*         <th scope="col">Gesamte Fahrten</th> *@
@*         @foreach (var days in DaysPartition) *@
@*         { *@
@*             <th scope="col">@days.Display()</th> *@
@*         } *@
@*     </tr> *@
@*     </thead> *@
@*     <tbody> *@
@*     @foreach (var (stat, rank) in GetStopStatistics(Entry).Select((stat, index) => (stat, index))) *@
@*     { *@
@*         <tr> *@
@*             <td>@(rank + 1)</td> *@
@*             <th scope="row">@stat.Stop.DisplayName(DateOnly.FromDateTime(DateTime.Now), Cities.Potsdam)</th> *@
@*             <td>@stat.TotalDepartures</td> *@
@*             @foreach (var departures in stat.Departures) *@
@*             { *@
@*                 <td>@departures</td> *@
@*             } *@
@*         </tr> *@
@*     } *@
@*     </tbody> *@
@* </table> *@
